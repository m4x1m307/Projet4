import random
import string
import tqdm
import argparse
import os

ENTRY_LENGTH = 100
KEY_LENGTH = 4
# Word list: operating-system-related terms.
# List of words generated by ChatGPT-4o.
WORDS = [
    "kernel", "process", "thread", "semaphore", "scheduler", "interrupt",
    "paging", "swapping", "context", "virtual", "memory", "filesystem",
    "inode", "bash", "shell", "tty", "device", "driver", "buffer", "cache",
    "daemon", "service", "init", "systemd", "fork", "exec", "pipe", "socket",
    "syscall", "signal", "mutex", "spinlock", "priority", "bootloader",
    "grub", "bios", "uefi", "userland", "privilege", "ring0", "ring3",
    "zombie", "orphan", "mount", "umount", "fstab", "cron", "logrotate",
    "journalctl", "dmesg", "lsmod", "modprobe", "chmod", "chown", "getty",
    "login", "logout", "passwd", "sudo", "su", "groupadd", "usermod",
    "kill", "ps", "top", "htop", "uptime", "nice", "renice", "vmstat",
    "iostat", "netstat", "ifconfig", "ip", "hostname", "uname", "whoami",
    "env", "export", "ldconfig", "strace", "lsof", "mkfs", "fsck", "blkid",
    "mountpoint", "swapoff", "swapon", "cronjob", "crontab", "logind",
    "runlevel", "halt", "reboot", "shutdown", "journal", "session",
    "namespace", "cgroup", "udev", "procfs", "sysfs"
]

seed = 42
random.seed(seed)

# upper case + lower case + digits
key_characters = string.ascii_letters + string.digits

# Used to avoid duplicate keys.
used_keys = set()

def generate_random_key():
    return ''.join(random.choices(key_characters, k=KEY_LENGTH))

def create_entry():
    # In this script, we ensure that the keys are unique.
    # However, this is not an assumption for the project.
    # When multiple entries with the same key are present,
    # then there may be multiple valid orderings.
    # The use of randomness to create unique keys is good for small files,
    # not so much for large files.
    key = generate_random_key()
    while key in used_keys:
        key = generate_random_key()
    used_keys.add(key)
    base = key + ','
    content = []
    total_len = ENTRY_LENGTH - 1 # 1 byte reserved for '\n'
    used = len(base)

    while True:
        word = random.choice(WORDS)
        content.append(word)
        used += len(word)
        if used + len(content) > total_len:
            break

    line = base + ','.join(content)
    assert len(line) >= total_len, f"Line too short: {line!r}"
    line = line[:total_len] # truncate to exactly 99 before newline

    return line + '\n'

def generate_file(num_lines=10):
    folder = "benchmarks"
    if not os.path.exists(folder):
        os.makedirs(folder)
    filename = folder + '/benchmark_' + str(num_lines) + '.txt'
    with open(filename, 'w', encoding='utf-8') as f:
        lines = []
        for _ in tqdm.trange(num_lines):
            line = create_entry()
            assert len(line.encode('utf-8')) == ENTRY_LENGTH,\
                   f"Line not {ENTRY_LENGTH} bytes: {line!r}"
            lines.append(line)
        
        print(f"Generated {num_lines} entries...")
        # Write all lines at once
        f.writelines(lines)
    print(f"File {filename} written successfully.")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description=f"Generate a fixed-length record file ({ENTRY_LENGTH} bytes per line).")
    parser.add_argument("num_entries",
                        type=int,
                        help="Number of entries to generate")
    args = parser.parse_args()

    assert args.num_entries > 0, "Number of entries must be positive"
    assert args.num_entries <= (len(key_characters) ** 4) * 3 / 4, (
        "Number of entries exceeds 3/4 of the total number of unique keys "
        "(4 characters each); due to the use of randomness to generate keys, "
        "this may be impossible or take a long time to generate all entries. "
        "To solve this, increase the number of possible characters."
    )
    generate_file(num_lines=args.num_entries)
